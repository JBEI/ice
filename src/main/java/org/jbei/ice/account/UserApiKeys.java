package org.jbei.ice.account;

import org.jbei.ice.access.AccessStatus;
import org.jbei.ice.access.PermissionException;
import org.jbei.ice.dto.access.AccessKey;
import org.jbei.ice.dto.common.Results;
import org.jbei.ice.logging.Logger;
import org.jbei.ice.storage.DAOException;
import org.jbei.ice.storage.DAOFactory;
import org.jbei.ice.storage.hibernate.dao.ApiKeyDAO;
import org.jbei.ice.storage.model.AccountModel;
import org.jbei.ice.storage.model.ApiKey;

import java.util.Date;
import java.util.List;
import java.util.Optional;

/**
 * API keys generated by users
 *
 * @author Hector Plahar
 */
public class UserApiKeys {

    private final String userId;
    private final ApiKeyDAO apiKeyDAO;
    private final AccountAuthorization authorization;

    public UserApiKeys(String userId) {
        this.userId = userId;
        this.apiKeyDAO = DAOFactory.getApiKeyDAO();
        this.authorization = new AccountAuthorization();
    }

    /**
     * Generates an access key using the client identifier
     *
     * @param clientId unique client identifier.
     * @return wrapper around created token, client_id and secret.
     * <p>The api token that is generated and returned to the user is not stored and therefore cannot be retrieved.
     * If lost, the api key record can be deleted by the user who created it (or an admin) and a new one created.</p>
     */
    public AccessKey requestKey(String clientId) {
        try {
            Optional<ApiKey> optional = apiKeyDAO.getByClientId(clientId);
            if (optional.isPresent())
                throw new IllegalArgumentException("Attempting to create duplicate key for client id " + clientId);
        } catch (DAOException e) {
            Logger.error(e);
            return null;
        }

        TokenHash hash = new TokenHash();
        String token = hash.generateRandomToken(32);
        String salt = hash.generateSalt();
        String hash_token = hash.encrypt(token, clientId + salt + clientId);

        ApiKey apiKey = new ApiKey();
        apiKey.setCreationTime(new Date());
        apiKey.setOwnerEmail(userId);
        apiKey.setClientId(clientId);
        apiKey.setSecret(salt);
        apiKey.setStatus(AccessStatus.OK);
        apiKey.setHashedToken(hash_token);

        apiKey = apiKeyDAO.create(apiKey);
        AccessKey key = apiKey.toDataTransferObject();
        key.setToken(token);
        return key;
    }

    /**
     * Retrieves either list of available keys for current user or all keys.
     * If requesting all keys then user must be an administrator
     *
     * @param limit        maximum number of keys to retrieve
     * @param offset       paging parameter start
     * @param sortField    field to sort on
     * @param asc          whether the retrieve order is in ascending order
     * @param getAvailable whether to retrieve all available keys or restrict by current user
     * @return wrapper around list of retrieved keys including number available
     * @throws PermissionException if <code>getAvailable</code> is true but user making the request does not have
     *                             administrative privileges
     */
    public Results<AccessKey> getKeys(int limit, int offset, String sortField, boolean asc, boolean getAvailable) {
        Results<AccessKey> accessKeyResults = new Results<>();
        List<ApiKey> results;
        boolean isAdmin = this.authorization.isAdministrator(this.userId);

        if (getAvailable) {
            if (!isAdmin)
                throw new PermissionException("Cannot retrieve all api keys without admin privileges");

            results = apiKeyDAO.getAllApiKeys(sortField, limit, offset, asc);
        } else {
            results = apiKeyDAO.getApiKeysForUser(userId, sortField, limit, offset, asc);
        }

        for (ApiKey key : results) {
            AccessKey accessKey = key.toDataTransferObject();
            AccountModel account = DAOFactory.getAccountDAO().getByEmail(key.getOwnerEmail());
            accessKey.setAccount(account.toDataTransferObject());
            accessKeyResults.getData().add(accessKey);
        }

        // get count
        String user = getAvailable ? null : this.userId;
        long count = apiKeyDAO.getApiKeysCount(user);
        accessKeyResults.setResultCount(count);
        return accessKeyResults;
    }

    /**
     * Deletes an api key
     *
     * @param id     unique database identifier for the key
     * @param secret unique key secret
     * @return true if the key is successfully deleted. false otherwise, including if the key cannot be found
     * @throws PermissionException if the key being deleted does not belong to user and user does not have
     *                             administrative privileges
     */
    public boolean deleteKey(long id, String secret) {
        ApiKey key = apiKeyDAO.get(id);
        if (key == null)
            return false;

        if (!key.getSecret().equalsIgnoreCase(secret))
            return false;

        if (!this.userId.equalsIgnoreCase(key.getOwnerEmail())) {
            boolean isAdmin = this.authorization.isAdministrator(this.userId);
            if (!isAdmin)
                throw new PermissionException("Cannot delete key you did not create without administrative privileges");
        }

        apiKeyDAO.delete(key);
        return true;
    }

    public AccessKey update(long id, AccessKey apiKey) {
        ApiKey key = apiKeyDAO.get(id);
        if (key == null)
            return null;

        if (!apiKey.getSecret().equals(key.getSecret()))
            throw new PermissionException("Mismatched api secret. Cannot update");

        // must be admin or owner to update
        if (!this.userId.equalsIgnoreCase(key.getOwnerEmail()))
            if (!this.authorization.isAdministrator(userId))
                throw new PermissionException("Invalid privileges to update access key");

        key.setAllowDelegate(apiKey.isAllowDelegate());
        key.setReadOnly(apiKey.isReadOnly());

        return apiKeyDAO.update(key).toDataTransferObject();
    }
}
